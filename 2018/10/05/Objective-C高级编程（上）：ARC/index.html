<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="《Objective-C高级编程：iOS与OS X多线程和内存管理》是iOS开发中一本经典书籍，书中有关ARC、Block、GCD的梳理是iOS开发进阶路上必不可少的知识储备。笔者读完此书后为了加强理解，特以笔记记之。本文为开篇，围绕ARC谈起Objective-C中的内存管理。">
<meta name="keywords" content="编程 写作 iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C高级编程（上）：ARC">
<meta property="og:url" content="http://yoursite.com/2018/10/05/Objective-C高级编程（上）：ARC/index.html">
<meta property="og:site_name" content="Rachal&#39;s blog">
<meta property="og:description" content="《Objective-C高级编程：iOS与OS X多线程和内存管理》是iOS开发中一本经典书籍，书中有关ARC、Block、GCD的梳理是iOS开发进阶路上必不可少的知识储备。笔者读完此书后为了加强理解，特以笔记记之。本文为开篇，围绕ARC谈起Objective-C中的内存管理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://mdimages.oss-cn-shanghai.aliyuncs.com/blog/2018/oc_advanced_arc.jpg">
<meta property="og:updated_time" content="2018-12-14T09:19:05.584Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C高级编程（上）：ARC">
<meta name="twitter:description" content="《Objective-C高级编程：iOS与OS X多线程和内存管理》是iOS开发中一本经典书籍，书中有关ARC、Block、GCD的梳理是iOS开发进阶路上必不可少的知识储备。笔者读完此书后为了加强理解，特以笔记记之。本文为开篇，围绕ARC谈起Objective-C中的内存管理。">
<meta name="twitter:image" content="https://mdimages.oss-cn-shanghai.aliyuncs.com/blog/2018/oc_advanced_arc.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/05/Objective-C高级编程（上）：ARC/">





  <title>Objective-C高级编程（上）：ARC | Rachal's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rachal's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Coding & Writing Here</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/05/Objective-C高级编程（上）：ARC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rachal Zhou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rachal's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Objective-C高级编程（上）：ARC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-05T10:22:31+08:00">
                2018-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">《Objective-C高级编程：iOS与OS X多线程和内存管理》</a>是iOS开发中一本经典书籍，书中有关ARC、Block、GCD的梳理是iOS开发进阶路上必不可少的知识储备。笔者读完此书后为了加强理解，特以笔记记之。本文为开篇，围绕ARC谈起Objective-C中的内存管理。</p>
<p><img src="https://mdimages.oss-cn-shanghai.aliyuncs.com/blog/2018/oc_advanced_arc.jpg" alt="ARC"></p>
<a id="more"></a>
<p>鉴于本书翻译自日文原版且翻译偏向书面，笔者希望采用通俗的语言记录，文章结构略有调整。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>ARC（自动引用计数）是iOS5、macOS10.7引入的内存管理技术，为了循序渐进的方式了解这项技术，本书先从ARC无效的环境说起，也就是常指的MRC（手动引用计数）环境。</p>
<p>本书开篇没有直接提及<strong>引用计数</strong>的概念，而是以<strong>办公室开灯关灯</strong>的例子引出内存管理的思考方式。作者认为理解内存管理时把注意力落在“生成”、“持有”、“释放”等管理操作上更为客观。</p>
<h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><ul>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>这里的“<strong>自己</strong>”理解为编程人员自身。与“生成”、“持有”、“释放”操作并列的还有“废弃”，分别对应以下方法：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objective-C方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td><code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td><code>retain</code>方法</td>
</tr>
<tr>
<td>释放对象</td>
<td><code>release</code>方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td><code>dealloc</code>方法</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：以上方法包含在Cocoa框架中而非Objective-C语言中。</li>
</ul>
<p><strong>自己生成的对象，自己所持有</strong></p>
<p>以下面名称开头的方法生成的对象为自己持有：</p>
<ul>
<li><code>alloc</code></li>
<li><code>new</code></li>
<li><code>copy</code></li>
<li><code>mutableCopy</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = [[NSObject alloc] init];// 自己生成并持有</span><br><span class="line">id obj2 = [NSObject new];// 自己生成并持有</span><br></pre></td></tr></table></figure>
<p>另外，根据以上原则，下列方法也意味着自己生成并持有对象：</p>
<ul>
<li><code>allocMyObject</code></li>
<li><code>newThatObject</code></li>
<li><code>copyThis</code></li>
<li><code>mutableCopyYourObject</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id obj = [MyObject allocMyObject];</span><br><span class="line"></span><br><span class="line">// 内部实现</span><br><span class="line">+ (MyObject *)allocMyObject &#123;</span><br><span class="line">    MyObject *obj = [[MyObject alloc] init];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非自己生成的对象，自己也能持有</strong></p>
<p><code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>以外方法取得对象，非自己生成，自己不持有对象。可以通过<code>retain</code>方法为自己所持有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [NSMutableArray array];// 取得对象，但自己不持有</span><br><span class="line">[obj retain];// 自己持有对象</span><br></pre></td></tr></table></figure>
<p><strong>不再需要自己持有的对象时释放</strong></p>
<p>自己持有的对象不再需要时，持有者有义务将其释放。释放使用<code>release</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];// 自己生成并持有对象</span><br><span class="line">[obj release];// 释放对象</span><br></pre></td></tr></table></figure>
<p>用<code>retain</code>方法持有对象，一旦不再需要，务必要用<code>release</code>方法释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [NSMutableArray array];// 取得对象，但自己不持有</span><br><span class="line">[obj retain];// 持有非自己生成对象</span><br><span class="line">[obj release];// 释放对象</span><br></pre></td></tr></table></figure>
<p>类似<code>[NSMutableArray array]</code>方法取得的对象存在，但自己不持有对象，内部如何实现？以<code>object</code>这个方法名为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)object &#123;</span><br><span class="line">    id obj = [[NSObject alloc] init];// 自己持有</span><br><span class="line">    [obj autorelease];// 适当时机自动释放</span><br><span class="line">    return obj;// 取得对象存在，但自己不持有</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>autorelease</code>提供这样的功能，使对象在超出指定的生存范围时能够自动并正确地释放。<br>使用<code>NSMutableArray</code>类的<code>array</code>类方法等可以取得谁都不持有的对象，这些方法是通过<code>autorelease</code>实现的。</p>
</blockquote>
<p><strong>非自己持有的对象无法释放</strong></p>
<p>用<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>方法生成并持有的对象，或用<code>retain</code>方法持有的对象，在不需要时要将其释放。倘若在应用程序中<strong>释放了非自己持有的对象会造成崩溃</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];// 自己生成并持有对象</span><br><span class="line">[obj release];// 释放对象</span><br><span class="line">[obj release];// 重复释放对象，崩溃</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = [obj0 object];// 取得对象，但自己不持有</span><br><span class="line">[obj1 release];// 释放非自己持有的对象，崩溃</span><br></pre></td></tr></table></figure>
<h3 id="alloc-retain-release-dealloc及其实现"><a href="#alloc-retain-release-dealloc及其实现" class="headerlink" title="alloc/retain/release/dealloc及其实现"></a>alloc/retain/release/dealloc及其实现</h3><p>Cocoa是macOS的系统框架，在iOS上被称为Cocoa Touch。Cocoa框架虽然没有公开，但是可以通过Cocoa框架的互换框架GNUstep来推测苹果的实现。</p>
<p><code>alloc</code>调用<code>allocWithZone</code>，那么这里的参数类型<code>NSZone</code>是什么？</p>
<blockquote>
<p>它是为了防止内存碎片化而引入的结构。对内存分配的区域本身进行多重化的管理，根据使用对象的目的、对象的大小分配内存，从而提高内存管理的效率。<br>现在运行时系统中的内存管理已经极具效率，使用区域来管理内存反而会引起内存使用效率低下以及源代码复杂等问题。</p>
</blockquote>
<h4 id="GNUstep的实现"><a href="#GNUstep的实现" class="headerlink" title="GNUstep的实现"></a>GNUstep的实现</h4><p>GNUstep源码里<code>alloc</code>类方法用<code>obj_layout</code>结构体中的整数变量<code>retained</code>来保存引用计数<code>retainCount</code>，并将其写入对象内存头部。</p>
<p>执行<code>alloc</code>后对象的实例方法<code>retainCount</code>获得数值是1，<code>retain</code>使变量<code>retained</code>值+1，<code>release</code>使变量<code>retained</code>值-1。<code>release</code>使<code>tetained</code>变量大于0时-1，等于0时调用<code>dealloc</code>实例方法，废弃对象。</p>
<p>具体总结如下：</p>
<ul>
<li>在Objective-C的对象中存有引用计数这一整数值。</li>
<li>调用<code>alloc</code>或是<code>retain</code>方法后，引用计数值+1。</li>
<li>调用<code>release</code>后，引用计数值-1。</li>
<li>引用计数值为0时，调用<code>dealloc</code>方法废弃对象。</li>
</ul>
<h4 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p><code>alloc</code>过程设置断点追踪调用的方法和函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+alloc</span><br><span class="line">+allocWithZone:</span><br><span class="line">class_createInstance</span><br><span class="line">calloc//分配内存块</span><br></pre></td></tr></table></figure>
<p>苹果对<code>alloc</code>的实现与GNUstep并无多大差异。</p>
<p><code>retainCount</code>/<code>retain</code>/<code>release</code>调用的方法和函数分别如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retainCount</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashGetCountOfKey</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-retain</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashAddValue</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-release</span><br><span class="line">__CFDoExternRefOperation</span><br><span class="line">CFBasicHashRemoveValue</span><br><span class="line">（CFBasicHashRemoveValue返回0时，-release 调用dealloc）</span><br></pre></td></tr></table></figure>
<p>可以从<code>__CFDoExternRefOperation</code>函数以及一些<code>CFBasicHash</code>开头的函数名看出，苹果的实现大概就是采用散列表（又称哈希表）来管理引用计数。</p>
<p>在引用计数表中，<code>key</code>为内存块地址，<code>value</code>为对应的引用计数，苹果这样实现的优势在于：</p>
<ul>
<li>为对象分配内存块时无需考虑内存块头部。</li>
<li>对象占用内存块损坏时，可以根据引用计数表来确认内存块的位置。</li>
<li>检测内存泄露时，根据引用计数表中的记录检查对象的持有者是否存在。</li>
</ul>
<h3 id="autorelease及其实现"><a href="#autorelease及其实现" class="headerlink" title="autorelease及其实现"></a>autorelease及其实现</h3><p><code>autorelease</code>会像C语言的自动变量那样对待对象实例。当超出其作用域时，对象实例的<code>release</code>实例方法被调用。</p>
<p><code>autorelease</code>具体使用方法如下：</p>
<ul>
<li>1.生成并持有<code>NSAutoreleasePool</code>对象；</li>
<li>2.调用已分配对象的<code>autorelease</code>实例方法；</li>
<li>3.废弃<code>NSAutoreleasePool</code>对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">[obj release];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>
<p>Cocoa框架中程序主循环的<code>NSRunLoop</code>对<code>NSAutoreleasePool</code>对象进行生成、持有和废弃处理。在大量产生<code>autorelease</code>对象时，若不废弃<code>NSAutoreleasePool</code>对象，那么生成的对象就不能被废弃，会产生内存不足现象。</p>
<h4 id="GNUstep的实现-1"><a href="#GNUstep的实现-1" class="headerlink" title="GNUstep的实现"></a>GNUstep的实现</h4><p><code>autorelease</code>实例方法的本质就是调用<code>NSAutoreleasePool</code>对象的<code>addObject</code>类方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj autorelease];</span><br></pre></td></tr></table></figure></p>
<p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)autorelease &#123;</span><br><span class="line">    [NSAutoreleasePool addObject:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GNUstep在实现<code>NSAutoreleasePool</code>时使用连接列表，可以理解为数组。若调用<code>NSObject</code>类的<code>autorelease</code>方法，该对象就会被追加到正在使用的<code>NSAutoreleasePool</code>对象的数组中。<code>drain</code>实例方法废弃正在使用的<code>NSAutoreleasePool</code>对象，会对数组中的所有对象调用<code>release</code>方法。</p>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>autoreleasepool以数组的形式实现，主要通过以下3个函数：</p>
<ul>
<li><code>obj_autoreleasePoolPush()</code></li>
<li><code>obj_autorelease(obj)</code></li>
<li><code>obj_autoreleasePoolPop(pool)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">/* 等同于objc_autoreleasePoolPush */</span><br><span class="line"></span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">[obj autorelease];</span><br><span class="line">/* 等同于 objc_autorelease(obj) */</span><br><span class="line"></span><br><span class="line">[pool drain];</span><br><span class="line">/* 等同于 objc_autoreleasePoolPop(pool) */</span><br></pre></td></tr></table></figure>
<p>以上是MRC环境下的内存管理及实现。</p>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><h3 id="ARC概述"><a href="#ARC概述" class="headerlink" title="ARC概述"></a>ARC概述</h3><p>ARC（Auto Reference Counting）是iOS5、macOS10.7（OS X Lion）引入的内存管理技术。</p>
<blockquote>
<p>ARC的出现解决了原来需要手动键入<code>retain</code>或<code>release</code>操作的问题。这在降低程序崩溃、内存风险的同时，很大程度上减少了开发程序的工作量。</p>
</blockquote>
<h3 id="内存管理的思考方式-1"><a href="#内存管理的思考方式-1" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><blockquote>
<p>“引用计数式内存管理”的本质在ARC中并没有改变，ARC只是自动地帮我们处理“引用计数”的相关部分。</p>
</blockquote>
<ul>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC环境下其类型必须附加所有权修饰符（有省略的情况），所有权修饰符有以下4种：</p>
<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autorelease</li>
</ul>
<p>书中此处提到<code>id</code>类型做一下记录：</p>
<blockquote>
<p>Objective-C中为了处理对象，可将变量定义为<code>id</code>类型，<code>id</code>类型用于隐藏对象类型的类名部分，相当于C语言中常用到的<code>void *</code>。</p>
</blockquote>
<h4 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h4><p><code>id</code>和对象类型默认使用<code>__strong</code>修饰，由于是默认情况，可省略不写。</p>
<p><code>__strong</code>表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。</p>
<p><code>__strong</code>同<code>__weak</code>、<code>__autoreleasing</code>一样，可以保证被修饰的变量在初始化时为<code>nil</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">//等同于</span><br><span class="line">//id __strong obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
<h4 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h4><blockquote>
<p>循环引用容易引起内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。使用<code>__weak</code>修饰符可以避免循环引用。</p>
</blockquote>
<p><code>__weak</code>表示弱引用，弱引用不能持有对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj = [[NSObject alloc] init];//编译器会警告</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>__weak</code>修饰符还有另一个优点。在持有对象的弱引用时，若对象被废弃，则此弱引用将失效且处于<code>nil</code>被赋值的状态。</p>
</blockquote>
<p>通过检查<code>__weak</code>修饰的变量是否为<code>nil</code>可以判断被赋值的对象是否已废弃。</p>
<p><code>__weak</code>只能用于iOS5和macOS10.7以上版本，在iOS4和macOS10.6及以前用<code>__unsafe_unretained</code>代替。</p>
<h4 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h4><p>ARC下指定<code>@autoreleasepool</code>块来替代<code>NSAutoreleasePool</code>类生成、持有及废弃这一范围。<code>__autoreleasing</code>修饰变量等价于对象调用<code>autorelease</code>方法，即可将对象注册到autoreleasepool中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提问：前文提到<code>__weak</code>修饰的变量必须注册到autoreleasepool中，为什么？</li>
<li>答：因为<code>__weak</code>修饰的变量只能持有对象的弱引用，在访问对象的过程中，该对象可能被废弃。如果把要访问的对象注册到autoreleasepool中，那么在<code>@autoreleasepool</code>块结束之前能确保该对象存在。</li>
</ul>
<p><code>_autoreleasing</code>同<code>__strong</code>一样，显式使用罕见。</p>
<h3 id="ARC的规则"><a href="#ARC的规则" class="headerlink" title="ARC的规则"></a>ARC的规则</h3><p>ARC环境下编译源代码遵循一定规则：</p>
<ul>
<li><strong>不能使用<code>retain</code>/<code>release</code>/<code>retainCount</code>/<code>autorelease</code></strong></li>
<li><strong>不能使用<code>NSAllocateObject</code>/<code>NSDeallocateObject</code></strong></li>
</ul>
<p>ARC有效时，以上方法会导致编译器报错。</p>
<ul>
<li><strong>必须遵守内存管理的方法命名规则</strong></li>
</ul>
<p>对象的生成、持有的方法必须遵循命名规则：<code>alloc</code>/<code>new</code>/<code>copy</code>/<code>mutableCopy</code>。以<code>init</code>开头的方法更严格：必须是实例方法且必须返回对象，返回对象的类型必须是<code>id</code>类型或该方法声明类的对象类型。</p>
<ul>
<li><strong>不要显式调用<code>dealloc</code></strong></li>
</ul>
<p><code>dealloc</code>方法无需显式调用，但C语言库需要在<code>dealloc</code>中<code>free</code>，以及删除已注册的通知观察者。</p>
<ul>
<li><strong>使用<code>@autorelease</code>块代替<code>NSAutoreleasePool</code></strong></li>
</ul>
<p>ARC有效时，使用<code>@autoreleasepool</code>块代替<code>NSAutoreleasePool</code>。</p>
<ul>
<li><strong>不能使用区域（<code>NSZone</code>）</strong></li>
</ul>
<p>不管ARC是否有效，区域在现在运行时系统中已单纯地被忽略。</p>
<ul>
<li>对象型变量不能作为C语言结构体（<code>struct</code>/<code>union</code>）的成员</li>
</ul>
<p>C语言的规约上没有方法来管理结构体成员变量的生存周期。</p>
<ul>
<li><strong>显式转换“<code>id</code>”和“<code>void *</code>”</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ARC无效 */</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = obj</span><br></pre></td></tr></table></figure>
<p>ARC有效时需要通过<code>__bridge</code>来显式转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* ARC有效 */</span><br><span class="line">id obj = [[NSObject alloc] init];</span><br><span class="line">void *p = (__bridge void*)obj;</span><br><span class="line">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure>
<h3 id="属性和数组"><a href="#属性和数组" class="headerlink" title="属性和数组"></a>属性和数组</h3><ul>
<li>声明属性所用的关键词与所有权修饰符的对应关系：</li>
</ul>
<table>
<thead>
<tr>
<th>声明属性的关键词</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<ul>
<li>动态数组中操作<code>__strong</code>修饰的变量与静态数组有很大差异，需要自己释放所有元素。静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，而在动态数组中，编译器不能确定数组的生存周期，所以无从处理。</li>
</ul>
<h2 id="ARC的实现"><a href="#ARC的实现" class="headerlink" title="ARC的实现"></a>ARC的实现</h2><h3 id="strong的实现"><a href="#strong的实现" class="headerlink" title="__strong的实现"></a>__strong的实现</h3><ul>
<li>自己生成并持有</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>
<ul>
<li>非自己生成持有</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id __strong obj = [NSMutableArray array];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(obj);</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>objc_retainAutoreleasedReturnValue</code>函数用于持有对象，注册到autoreleasepool中并返回。与之对应的函数是<code>objc_autoreleaseReturnValue</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>objc_retainAutoreleasedReturnValue</code>函数和<code>objc_autoreleaseReturnValue</code>函数的协作，可以不将对象注册到autoreleasepool中而直接传递，以达到<strong>最优化程序运行</strong>。</p>
</blockquote>
<h3 id="weak的实现"><a href="#weak的实现" class="headerlink" title="__weak的实现"></a>__weak的实现</h3><blockquote>
<p>使用<code>__weak</code>修饰的变量，就是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 编译器模拟代码 */</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">objc_destroyWeak(obj1);</span><br></pre></td></tr></table></figure>
<p><code>__weak</code>同引用计数一样通过散列表（哈希表）实现，大致流程如下：</p>
<ul>
<li>1.<code>objc_initWeak(&amp;obj1, obj)</code>函数初始化<code>__weak</code>修饰的变量，通过执行<code>objc_storeWeak(&amp;obj1, obj)</code>函数，以第一个参数（变量的地址）作为<code>key</code>，把第二个参数（赋值对象）作为<code>value</code>存入哈希表。</li>
<li>2.由于弱引用不能持有对象，函数<code>objc_loadWeakRetained(&amp;obj1)</code>取出所引用的对象并<code>retain</code>。</li>
<li>3.<code>objc_autorelease(tmp)</code>函数将对象注册到<code>autoreleasepool</code>中。</li>
<li>4.<code>objc_destroyWeak(&amp;obj1)</code>函数释放<code>__weak</code>修饰的变量，通过过程执行<code>objc_store(&amp;obj1, 0)</code>函数，在weak表中查到变量地址并删除。废弃对象调用<code>objc_clear_deallocating</code>函数，这个过程会将weak表记录中<code>__weak</code>修饰的变量地址赋值为<code>nil</code>。</li>
</ul>
<blockquote>
<p>如果大量使用<code>__weak</code>修饰的变量，则会消耗相应的CPU资源。良策是只在需要避免循环引用时使用<code>__weak</code>修饰符。</p>
</blockquote>
<h3 id="autoreleasing的实现"><a href="#autoreleasing的实现" class="headerlink" title="__autoreleasing的实现"></a>__autoreleasing的实现</h3><p><code>_autoreleasing</code>修饰变量，等同于ARC无效时对象调用<code>autorelease</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 编译器的模拟代码 */</span><br><span class="line">id pool = objc_autoreleasePoolPush();</span><br><span class="line">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class="line">objc_msgSend(obj, @selector(init));</span><br><span class="line">objc_autorelese(obj);</span><br><span class="line">objc_autoreleasePoolPop();</span><br></pre></td></tr></table></figure>
<p>以上为ARC篇的学习内容。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Rachal Zhou 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Rachal Zhou 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/21/重识iOS之Property/" rel="next" title="重识iOS之Property">
                <i class="fa fa-chevron-left"></i> 重识iOS之Property
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/12/Objective-C高级编程（中）：Block/" rel="prev" title="Objective-C高级编程（中）：Block">
                Objective-C高级编程（中）：Block <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Rachal Zhou">
            
              <p class="site-author-name" itemprop="name">Rachal Zhou</p>
              <p class="site-description motion-element" itemprop="description">Coding is a lifestyle</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/RachalZhou" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/57049495aedc" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-book"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zrcrachal@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/2502268124" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理的思考方式"><span class="nav-number">1.1.</span> <span class="nav-text">内存管理的思考方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc-retain-release-dealloc及其实现"><span class="nav-number">1.2.</span> <span class="nav-text">alloc/retain/release/dealloc及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep的实现"><span class="nav-number">1.2.1.</span> <span class="nav-text">GNUstep的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#苹果的实现"><span class="nav-number">1.2.2.</span> <span class="nav-text">苹果的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autorelease及其实现"><span class="nav-number">1.3.</span> <span class="nav-text">autorelease及其实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep的实现-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">GNUstep的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#苹果的实现-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">苹果的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC"><span class="nav-number">2.</span> <span class="nav-text">ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC概述"><span class="nav-number">2.1.</span> <span class="nav-text">ARC概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理的思考方式-1"><span class="nav-number">2.2.</span> <span class="nav-text">内存管理的思考方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#所有权修饰符"><span class="nav-number">2.3.</span> <span class="nav-text">所有权修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#strong修饰符"><span class="nav-number">2.3.1.</span> <span class="nav-text">__strong修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak修饰符"><span class="nav-number">2.3.2.</span> <span class="nav-text">__weak修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#autoreleasing修饰符"><span class="nav-number">2.3.3.</span> <span class="nav-text">__autoreleasing修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC的规则"><span class="nav-number">2.4.</span> <span class="nav-text">ARC的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性和数组"><span class="nav-number">2.5.</span> <span class="nav-text">属性和数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC的实现"><span class="nav-number">3.</span> <span class="nav-text">ARC的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strong的实现"><span class="nav-number">3.1.</span> <span class="nav-text">__strong的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak的实现"><span class="nav-number">3.2.</span> <span class="nav-text">__weak的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoreleasing的实现"><span class="nav-number">3.3.</span> <span class="nav-text">__autoreleasing的实现</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rachal Zhou</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
